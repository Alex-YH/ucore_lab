# Lab2 
# 杨皓 2012013320

## 练习1

first-fit的实现主要由以下几个部分组成

1. 初始化
首先，在default_init_memmap函数中对各页块进行初始化，首先将所有的page结构体的各字段置0，之后再将header page变量base的property字段开启并设置为内存块大小。完成此工作之后即意味着已经将base设置为来内存块的头部，之后再将其加入链表中。此时即完成来初始化工作。

2. 内存分配函数
首先，从空闲空间列表的首元素开始遍历，寻找第一个大小大于所需要分配大小的内存块。之后再进行分类讨论，若该内存块的大小恰好等于所需要分配的大小，则直接将该块从空闲空间链表中删去；若该内存块的大小大于所需要分配的大小，则将重新生成一个链表项，该链表项的大小为原内存块的大小减去需要分配的内存大小，并将该块替换至原内存块在链表中的位置即可。

3. 释放free
首先遍历链表直至第一次出现内存地址高于即将释放的内存块的地址。在这之前，搜索是否有内存块能合并，若能则生成一个大小更大的块。将该新的块替换为旧的块。之后直接退出即可。

4. 改进空间
本算法已经将链表项设置为整个内存块，故对于时间与空间上都已经有了较大的提高，可以尝试通过别的类型的算法来提高效率。

## 练习2

1. 页目录表项和页表项各个标志位

```
#define PTE_P           0x001                   该页是否已经被使用，已再ucore中使用
#define PTE_W           0x002                   该页是否可写，已再ucore中使用
#define PTE_U           0x004                   该页是否可以在用户态中使用，已在ucore中使用
#define PTE_PWT         0x008                   是否使用写直达状态，在cache中使用
#define PTE_PCD         0x010                   是否禁止使用cache，在cache中使用
#define PTE_A           0x020                   该页是否被访问过
#define PTE_D           0x040                   该页中的数据是否已经被修改
#define PTE_PS          0x080                   该页的大小设置
#define PTE_MBZ         0x180                   保留位，置0
#define PTE_AVAIL       0xE00                   软件是否能使用
```

2. 当发生页访问异常时，将会把异常信息以及程序的状态保存在CR寄存器中，之后通过查询中断描述符表来寻找对应的中断处理例程位置，之后将转至中断执行程序的位置，进而处理异常程序。

## 练习3

1. Page的全局变量表示的是物理内存中的页，对应着页表以及页目录中所存储的页。

2. 将ucore的起始地址以及虚地址设置为相同的值即可，即将其改成0x100000.

## 与参考答案的区别

练习一的代码实现与参考答案完全不一样，原答案将所有的page都放入来空闲链表中，而本人的代码将每个空闲块的头部放入空闲链表中。可以说，在时间与空间上相较于参考答案而言都有来大大的提高。个人认为我的算法相对于参考答案而言还是非常有优势的，既容易实现，效率也很高。
练习二与练习三由于较为简单，故与参考答案较为相似，具体差别体现在实现方式上。

## 实验总结

本次实验使我非常全面的了解来操作系统内存管理的实现机制，通过自己实现以及观察发现来空闲链表可以与实际的内存地址进行转换。这是一件非常有收获的事情，希望之后能再实现一些别的算法，在性能上更近一步。
