# Lab4 实验报告
# 杨皓 2012013320

## 练习1

1. 实现过程
本练习完成的是给新创建的进程对应的结构成员进行初始化，故由于ucore中新创建的进程的状态为PROC_UNINIT，故将进程的状态设置。之后，由于还未进行进程id的分配，所以先将pid置-1，之后再给其分配对应的值。之后再将其它非分配状态的成员置0，并为其中部分成员分配内存空间。此时，即完成了本练习。

2. context成员变量含义及作用
该变量用于保存程序运行的上下文，其成员是寄存器的数值，用于在进程切换时保存程序状态。	

3. trapframe成员变量及作用
该变量为进程的中断帧，用于在中断时保存中断前的状态。

4. 与参考答案不同点：由于本练习非常简单，故与参考答案基本一致。

## 练习2

1. 实现过程
首先使用alloc_proc函数为新进程分配一个PCB，之后设置栈结构并复制地址空间，再将父进程id设置为当前进程。再将进程的执行状态复制到新的栈和地址空间中，再为进程分配进程id，将PCB加入hash链表以及proc_list中，最后将进程唤醒。

2. ucore是否给每一个新fork的线程一个唯一的id？请说明你的分析和理由
每一个新fork的进线程都有一个唯一的id。通过查看get_pid函数可以发现，每次分配的时候，该函数会将上次的pid+1，若与现有pid相同，则继续重复上述操作，直至找到可以用的pid，故在进程数量不超过MAX_PROCESS宏的数值时，每个线程的pid都是唯一的。

3. 与参考答案不同点
参考答案使用了local_intr_save以及local_intr_store关闭和开启中断，而我没有。

## 练习3

1. 在本实验的执行过程中，创建且运行了几个内核线程
总共创建了2个内核线程，一个是最开始的内核线程idleproc，另一个是由idleproc创建的initproc。

2. local_intr_save(intr_flag);....local_intr_restore(intr_flag)的作用
该两函数分别禁止以及使能啦中断，防止在进程切换的过程中不受打扰。

3. proc_run函数分析
该函数实现了一个进程到另一个进程的切换。首先判断要切换的进程是否与当前进程相同，之后再禁止中断，切换内核堆栈，切换页目录基址。再通过调用switch_to切换进程的上下文，最后再使能中断即可。

## 总结
本次试验的主要知识点在于进程创建的具体细节，以及fork的实现细节。  
但对于进程的各种状态以及进程的控制都是在实验中没有涉及的。
